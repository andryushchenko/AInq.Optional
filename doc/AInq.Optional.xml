<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AInq.Optional</name>
    </assembly>
    <members>
        <member name="T:AInq.Optional.ActionExtension">
            <summary> Value processing extension </summary>
        </member>
        <member name="M:AInq.Optional.ActionExtension.Do``1(AInq.Optional.Maybe{``0},System.Action{``0})">
            <summary> Do action with value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <typeparam name="T"> Source value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.Do``1(AInq.Optional.Try{``0},System.Action{``0})">
            <summary> Do action with value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <typeparam name="T"> Source value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoLeft``2(AInq.Optional.Either{``0,``1},System.Action{``0})">
            <summary> Do action with left value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoRight``2(AInq.Optional.Either{``0,``1},System.Action{``1})">
            <summary> Do action with right value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary> Do asynchronous action with value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <param name="cancellation"> Cancellation Token </param>
            <typeparam name="T"> Source value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <inheritdoc cref="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Try{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary> Do asynchronous action with value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <param name="cancellation"> Cancellation Token </param>
            <typeparam name="T"> Source value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Try{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <inheritdoc cref="M:AInq.Optional.ActionExtension.DoAsync``1(AInq.Optional.Try{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoLeftAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary> Do asynchronous action with left value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <param name="cancellation"> Cancellation Token </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoLeftAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.Tasks.Task})">
            <inheritdoc cref="M:AInq.Optional.ActionExtension.DoLeftAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoRightAsync``2(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary> Do asynchronous action with right value (if exists) </summary>
            <param name="item"> Source </param>
            <param name="action"> Action </param>
            <param name="cancellation"> Cancellation Token </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoRightAsync``2(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.Tasks.Task})">
            <inheritdoc cref="M:AInq.Optional.ActionExtension.DoRightAsync``2(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary> Do asynchronous action with left or right value </summary>
            <param name="item"> Source </param>
            <param name="leftAction"> Left value action </param>
            <param name="rightAction"> Right value action </param>
            <param name="cancellation"> Cancellation Token </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ActionExtension.DoAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.Tasks.Task},System.Func{``1,System.Threading.Tasks.Task})">
            <inheritdoc
                cref="M:AInq.Optional.ActionExtension.DoAsync``2(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
        </member>
        <member name="T:AInq.Optional.AsyncExtension">
            <summary> Asynchronous utils </summary>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.ResultAsync``1(System.Threading.Tasks.Task{``0})">
            <summary> Create Try from value task </summary>
            <param name="task"> Value task </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.UnwrapAsync``1(AInq.Optional.Try{System.Threading.Tasks.Task{``0}})">
            <summary> Unwrap to Task </summary>
            <param name="task"> Try with task </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary> Convert to other value type asynchronously </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="cancellation"> Cancellation token </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <inheritdoc cref="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Maybe{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Try{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary> Convert to other value type asynchronously </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="cancellation"> Cancellation token </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Try{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <inheritdoc cref="M:AInq.Optional.AsyncExtension.SelectAsync``2(AInq.Optional.Try{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectLeftAsync``3(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Threading.CancellationToken)">
            <summary> Convert to other left value type asynchronously </summary>
            <param name="item"> Source </param>
            <param name="leftSelector"> Left value converter </param>
            <param name="cancellation"> Cancellation token </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
            <typeparam name="TLeftResult"> Left result type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectLeftAsync``3(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.Tasks.Task{``2}})">
            <inheritdoc cref="M:AInq.Optional.AsyncExtension.SelectLeftAsync``3(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectRightAsync``3(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Threading.CancellationToken)">
            <summary> Convert to other right value type asynchronously </summary>
            <param name="item"> Source </param>
            <param name="rightSelector"> Right value converter </param>
            <param name="cancellation"> Cancellation token </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <typeparam name="TRightResult"> Right result type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectRightAsync``3(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <inheritdoc
                cref="M:AInq.Optional.AsyncExtension.SelectRightAsync``3(AInq.Optional.Either{``0,``1},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Threading.CancellationToken)" />
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``4(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``3}},System.Threading.CancellationToken)">
            <summary> Convert to other type asynchronously </summary>
            <param name="item"> Source </param>
            <param name="leftSelector"> Left value converter </param>
            <param name="rightSelector"> Right value converter </param>
            <param name="cancellation"> Cancellation token </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <typeparam name="TLeftResult"> Left result type </typeparam>
            <typeparam name="TRightResult"> Right result type </typeparam>
        </member>
        <member name="M:AInq.Optional.AsyncExtension.SelectAsync``4(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.Tasks.Task{``2}},System.Func{``1,System.Threading.Tasks.Task{``3}})">
            <inheritdoc
                cref="M:AInq.Optional.AsyncExtension.SelectAsync``4(AInq.Optional.Either{``0,``1},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``3}},System.Threading.CancellationToken)" />
        </member>
        <member name="T:AInq.Optional.ConvertExtension">
            <summary> Monad convert utils </summary>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.LeftOrNone``2(AInq.Optional.Either{``0,``1})">
            <summary> Get left value or none  </summary>
            <param name="item"> Source </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Maybe with left value </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.RightOrNone``2(AInq.Optional.Either{``0,``1})">
            <summary> Get right value or none  </summary>
            <param name="item"> Source </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Maybe with right value </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.TryLeft``2(AInq.Optional.Either{``0,``1})">
            <summary> Try get left value  </summary>
            <param name="item"> Source </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Try with left value </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.TryRight``2(AInq.Optional.Either{``0,``1})">
            <summary> Try get right value  </summary>
            <param name="item"> Source </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Try with right value </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.Or``2(AInq.Optional.Maybe{``0},``1)">
            <summary> Get source value or other if empty  </summary>
            <param name="item"> Maybe source </param>
            <param name="other"> Other value </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Either </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.Or``2(AInq.Optional.Try{``0},``1)">
            <summary> Get source value or other if exception  </summary>
            <param name="item"> Maybe source </param>
            <param name="other"> Other value </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Either </returns>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.Or``1(AInq.Optional.Maybe{``0},AInq.Optional.Try{``0})">
            <summary> Get value form this item or other  </summary>
            <param name="item"> Maybe </param>
            <param name="other"> Try </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.Or``1(AInq.Optional.Try{``0},AInq.Optional.Maybe{``0})">
            <summary> Get value form this item or other  </summary>
            <param name="item"> Try </param>
            <param name="other"> Maybe </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.AsTry``1(AInq.Optional.Maybe{``0})">
            <summary> Convert <see cref="T:AInq.Optional.Maybe`1" /> to <see cref="T:AInq.Optional.Try`1" />  </summary>
            <param name="item"> Maybe </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.ConvertExtension.AsMaybe``1(AInq.Optional.Try{``0})">
            <summary> Convert <see cref="T:AInq.Optional.Try`1" /> to <see cref="T:AInq.Optional.Maybe`1" />  </summary>
            <param name="item"> Try </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="T:AInq.Optional.Either">
            <summary> Either utils </summary>
        </member>
        <member name="M:AInq.Optional.Either.Left``2(``0)">
            <summary> Create Either from left value </summary>
            <param name="left"> Value </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.Right``2(``1)">
            <summary> Create Either from right value </summary>
            <param name="right"> Value </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.SelectLeft``3(AInq.Optional.Either{``0,``1},System.Func{``0,``2})">
            <summary> Convert to other left value type </summary>
            <param name="item"> Source </param>
            <param name="leftSelector"> Left value converter </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
            <typeparam name="TLeftResult"> Left result type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.SelectRight``3(AInq.Optional.Either{``0,``1},System.Func{``1,``2})">
            <summary> Convert to other right value type </summary>
            <param name="item"> Source </param>
            <param name="rightSelector"> Right value converter </param>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <typeparam name="TRightResult"> Right result type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.Select``4(AInq.Optional.Either{``0,``1},System.Func{``0,``2},System.Func{``1,``3})">
            <summary> Convert to other type </summary>
            <param name="item"> Source </param>
            <param name="leftSelector"> Left value converter </param>
            <param name="rightSelector"> Right value converter </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <typeparam name="TLeftResult"> Left result type </typeparam>
            <typeparam name="TRightResult"> Right result type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.LeftOrDefault``2(AInq.Optional.Either{``0,``1},``0)">
            <summary> Get left value or default </summary>
            <param name="item"> Source </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.LeftOrDefault``2(AInq.Optional.Either{``0,``1},System.Func{``0})">
            <summary> Get left value or default from generator </summary>
            <param name="item"> Source </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.RightOrDefault``2(AInq.Optional.Either{``0,``1},``1)">
            <summary> Get right value or default </summary>
            <param name="item"> Source </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.RightOrDefault``2(AInq.Optional.Either{``0,``1},System.Func{``1})">
            <summary> Get right value or default from generator </summary>
            <param name="item"> Source </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.ToLeft``2(AInq.Optional.Either{``0,``1},System.Func{``1,``0})">
            <summary> Convert to left value type </summary>
            <param name="item"> Source </param>
            <param name="rightToLeft"> Right to left converter </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="M:AInq.Optional.Either.ToRight``2(AInq.Optional.Either{``0,``1},System.Func{``0,``1})">
            <summary> Convert to right value type </summary>
            <param name="item"> Source </param>
            <param name="leftToRight"> Left to right converter </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
        </member>
        <member name="T:AInq.Optional.Either`2">
            <summary> Either monad </summary>
            <typeparam name="TLeft"> Left value type </typeparam>
            <typeparam name="TRight"> Right value type </typeparam>
            <remarks> DO NOT create <see cref="T:AInq.Optional.Either`2" /> directly, use <see cref="M:AInq.Optional.Either.Right``2(``1)" /> and <see cref="M:AInq.Optional.Either.Left``2(``0)" /> </remarks>
        </member>
        <member name="P:AInq.Optional.Either`2.HasLeft">
            <summary> Check if item contains left value </summary>
        </member>
        <member name="P:AInq.Optional.Either`2.HasRight">
            <summary> Check if item contains right value </summary>
        </member>
        <member name="P:AInq.Optional.Either`2.Left">
            <summary> Left value (if exists) </summary>
        </member>
        <member name="P:AInq.Optional.Either`2.Right">
            <summary> Right value (if exists) </summary>
        </member>
        <member name="M:AInq.Optional.Either`2.Invert">
            <summary> Swap left and right values </summary>
        </member>
        <member name="M:AInq.Optional.Either`2.ToString">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Either`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Either`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Either`2.Equals(AInq.Optional.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Either`2.op_Explicit(`0)~AInq.Optional.Either{`0,`1}">
            <summary> Explicit cast to Either </summary>
            <param name="item"> Value </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Explicit(`1)~AInq.Optional.Either{`0,`1}">
            <summary> Explicit cast to Either </summary>
            <param name="item"> Value </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Explicit(AInq.Optional.Either{`0,`1})~`0">
            <summary> Explicit cast to left value type </summary>
            <param name="item"> Either item </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Explicit(AInq.Optional.Either{`0,`1})~`1">
            <summary> Explicit cast to right value type </summary>
            <param name="item"> Either item </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(AInq.Optional.Either{`0,`1},AInq.Optional.Either{`0,`1})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(AInq.Optional.Either{`0,`1},AInq.Optional.Either{`0,`1})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(AInq.Optional.Either{`0,`1},AInq.Optional.Either{`1,`0})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(AInq.Optional.Either{`0,`1},AInq.Optional.Either{`1,`0})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(AInq.Optional.Either{`0,`1},`0)">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(AInq.Optional.Either{`0,`1},`0)">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(AInq.Optional.Either{`0,`1},`1)">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(AInq.Optional.Either{`0,`1},`1)">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(`0,AInq.Optional.Either{`0,`1})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(`0,AInq.Optional.Either{`0,`1})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Equality(`1,AInq.Optional.Either{`0,`1})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Either`2.op_Inequality(`1,AInq.Optional.Either{`0,`1})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="T:AInq.Optional.EnumerableExtension">
            <summary> Monad collection utils </summary>
        </member>
        <member name="M:AInq.Optional.EnumerableExtension.Values``1(System.Collections.Generic.IEnumerable{AInq.Optional.Maybe{``0}})">
            <summary> Select existing values </summary>
            <param name="collection"> Maybe collection </param>
            <typeparam name="T"> Value type </typeparam>
            <returns> Values collection </returns>
        </member>
        <member name="M:AInq.Optional.EnumerableExtension.Values``1(System.Collections.Generic.IEnumerable{AInq.Optional.Try{``0}})">
            <summary> Select existing values </summary>
            <param name="collection"> Try collection </param>
            <typeparam name="T"> Value type </typeparam>
            <returns> Values collection </returns>
        </member>
        <member name="M:AInq.Optional.EnumerableExtension.LeftValues``2(System.Collections.Generic.IEnumerable{AInq.Optional.Either{``0,``1}})">
            <summary> Select existing left values </summary>
            <param name="collection"> Either collection </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Left values collection </returns>
        </member>
        <member name="M:AInq.Optional.EnumerableExtension.RightValues``2(System.Collections.Generic.IEnumerable{AInq.Optional.Either{``0,``1}})">
            <summary> Select existing right values </summary>
            <param name="collection"> Either collection </param>
            <typeparam name="TLeft"> Left source type </typeparam>
            <typeparam name="TRight"> Right source type </typeparam>
            <returns> Right values collection </returns>
        </member>
        <member name="T:AInq.Optional.Maybe">
            <summary> Maybe utils </summary>
        </member>
        <member name="M:AInq.Optional.Maybe.None``1">
            <summary> Create empty Maybe </summary>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.Value``1(``0)">
            <summary> Create Maybe from value </summary>
            <param name="value"> Value </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.Select``2(AInq.Optional.Maybe{``0},System.Func{``0,``1})">
            <summary> Convert to other value type </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.SelectOrDefault``2(AInq.Optional.Maybe{``0},System.Func{``0,``1},``1)">
            <summary> Convert to other value type or default </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.SelectOrDefault``2(AInq.Optional.Maybe{``0},System.Func{``0,``1},System.Func{``1})">
            <summary> Convert to other value type or default from generator </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.Select``2(AInq.Optional.Maybe{``0},System.Func{``0,AInq.Optional.Maybe{``1}})">
            <summary> Convert to other value type </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.SelectOrDefault``2(AInq.Optional.Maybe{``0},System.Func{``0,AInq.Optional.Maybe{``1}},``1)">
            <summary> Convert to other value type or default </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.SelectOrDefault``2(AInq.Optional.Maybe{``0},System.Func{``0,AInq.Optional.Maybe{``1}},System.Func{``1})">
            <summary> Convert to other value type or default from generator </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.ValueOrDefault``1(AInq.Optional.Maybe{``0},``0)">
            <summary> Get value or default </summary>
            <param name="item"> Source </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.ValueOrDefault``1(AInq.Optional.Maybe{``0},System.Func{``0})">
            <summary> Get value or default from generator </summary>
            <param name="item"> Source </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.Or``1(AInq.Optional.Maybe{``0},AInq.Optional.Maybe{``0})">
            <summary> Get value form this item or other </summary>
            <param name="item"> Source </param>
            <param name="other"> Other </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Maybe.Unwrap``1(AInq.Optional.Maybe{AInq.Optional.Maybe{``0}})">
            <summary> Unwrap nested Maybe </summary>
            <param name="item"> Source </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="T:AInq.Optional.Maybe`1">
            <summary> Maybe monad </summary>
            <typeparam name="T"> Value type </typeparam>
            <remarks> DO NOT create <see cref="T:AInq.Optional.Maybe`1"/> directly, use <see cref="M:AInq.Optional.Maybe.Value``1(``0)"/> and <see cref="M:AInq.Optional.Maybe.None``1"/> </remarks>
        </member>
        <member name="P:AInq.Optional.Maybe`1.HasValue">
            <summary> Check if item contains value </summary>
        </member>
        <member name="P:AInq.Optional.Maybe`1.Value">
            <summary> Item value (if exists) </summary>
        </member>
        <member name="M:AInq.Optional.Maybe`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.Equals(AInq.Optional.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.Equals(`0)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.CompareTo(AInq.Optional.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.CompareTo(`0)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Explicit(`0)~AInq.Optional.Maybe{`0}">
            <summary> Explicit cast to Maybe </summary>
            <param name="item"> Value </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Explicit(AInq.Optional.Maybe{`0})~`0">
            <summary> Explicit cast to value type </summary>
            <param name="item"> Maybe item </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Equality(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Inequality(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThan(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThan(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThanOrEqual(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThanOrEqual(AInq.Optional.Maybe{`0},AInq.Optional.Maybe{`0})">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Equality(AInq.Optional.Maybe{`0},`0)">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Inequality(AInq.Optional.Maybe{`0},`0)">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThan(AInq.Optional.Maybe{`0},`0)">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThan(AInq.Optional.Maybe{`0},`0)">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThanOrEqual(AInq.Optional.Maybe{`0},`0)">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThanOrEqual(AInq.Optional.Maybe{`0},`0)">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Equality(`0,AInq.Optional.Maybe{`0})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_Inequality(`0,AInq.Optional.Maybe{`0})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThan(`0,AInq.Optional.Maybe{`0})">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThan(`0,AInq.Optional.Maybe{`0})">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_LessThanOrEqual(`0,AInq.Optional.Maybe{`0})">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Maybe`1.op_GreaterThanOrEqual(`0,AInq.Optional.Maybe{`0})">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="T:AInq.Optional.Try">
            <summary> Try utils </summary>
        </member>
        <member name="M:AInq.Optional.Try.Value``1(``0)">
            <summary> Create Try from value </summary>
            <param name="value"> Value </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Error``1(System.Exception)">
            <summary> Create Try from exception </summary>
            <param name="exception"> Exception </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Result``1(System.Func{``0})">
            <summary> Create Try from value generator </summary>
            <param name="generator"> Value generator </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Select``2(AInq.Optional.Try{``0},System.Func{``0,``1})">
            <summary> Convert to other value type </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.SelectOrDefault``2(AInq.Optional.Try{``0},System.Func{``0,``1},``1)">
            <summary> Convert to other value type or default </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.SelectOrDefault``2(AInq.Optional.Try{``0},System.Func{``0,``1},System.Func{``1})">
            <summary> Convert to other value type or default from generator </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Select``2(AInq.Optional.Try{``0},System.Func{``0,AInq.Optional.Try{``1}})">
            <summary> Convert to other value type </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.SelectOrDefault``2(AInq.Optional.Try{``0},System.Func{``0,AInq.Optional.Try{``1}},``1)">
            <summary> Convert to other value type or default </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.SelectOrDefault``2(AInq.Optional.Try{``0},System.Func{``0,AInq.Optional.Try{``1}},System.Func{``1})">
            <summary> Convert to other value type or default from generator </summary>
            <param name="item"> Source </param>
            <param name="selector"> Converter </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Source value type </typeparam>
            <typeparam name="TResult"> Result value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.ValueOrDefault``1(AInq.Optional.Try{``0},``0)">
            <summary> Get value or default </summary>
            <param name="item"> Source </param>
            <param name="defaultValue"> Default value </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.ValueOrDefault``1(AInq.Optional.Try{``0},System.Func{``0})">
            <summary> Get value or default from generator </summary>
            <param name="item"> Source </param>
            <param name="defaultGenerator"> Default value generator </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Or``1(AInq.Optional.Try{``0},AInq.Optional.Try{``0})">
            <summary> Get value form this item or other </summary>
            <param name="item"> Source </param>
            <param name="other"> Other </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="M:AInq.Optional.Try.Unwrap``1(AInq.Optional.Try{AInq.Optional.Try{``0}})">
            <summary> Unwrap nested Try </summary>
            <param name="item"> Source </param>
            <typeparam name="T"> Value type </typeparam>
        </member>
        <member name="T:AInq.Optional.Try`1">
            <summary> Try monad </summary>
            <typeparam name="T"> Value type </typeparam>
            <remarks> DO NOT create <see cref="T:AInq.Optional.Try`1"/> directly, use <see cref="M:AInq.Optional.Try.Value``1(``0)"/> and <see cref="M:AInq.Optional.Try.Error``1(System.Exception)"/> </remarks>
        </member>
        <member name="P:AInq.Optional.Try`1.Success">
            <summary> Check if item is success </summary>
        </member>
        <member name="P:AInq.Optional.Try`1.Value">
            <summary> Item value (if success) </summary>
        </member>
        <member name="P:AInq.Optional.Try`1.Error">
            <summary> Exception or null if success </summary>
        </member>
        <member name="M:AInq.Optional.Try`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.Equals(AInq.Optional.Try{`0})">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.Equals(`0)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.CompareTo(AInq.Optional.Try{`0})">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.CompareTo(`0)">
            <inheritdoc />
        </member>
        <member name="M:AInq.Optional.Try`1.op_Explicit(`0)~AInq.Optional.Try{`0}">
            <summary> Explicit cast to Try </summary>
            <param name="item"> Value </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Explicit(System.Exception)~AInq.Optional.Try{`0}">
            <summary> Explicit cast to Try </summary>
            <param name="exception"> Exception </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Explicit(AInq.Optional.Try{`0})~`0">
            <summary> Explicit cast to value type </summary>
            <param name="item"> Try item </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Equality(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Inequality(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThan(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThan(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThanOrEqual(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThanOrEqual(AInq.Optional.Try{`0},AInq.Optional.Try{`0})">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Equality(AInq.Optional.Try{`0},`0)">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Inequality(AInq.Optional.Try{`0},`0)">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThan(AInq.Optional.Try{`0},`0)">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThan(AInq.Optional.Try{`0},`0)">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThanOrEqual(AInq.Optional.Try{`0},`0)">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThanOrEqual(AInq.Optional.Try{`0},`0)">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Equality(`0,AInq.Optional.Try{`0})">
            <summary> Equality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_Inequality(`0,AInq.Optional.Try{`0})">
            <summary> Inequality comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThan(`0,AInq.Optional.Try{`0})">
            <summary> Less comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThan(`0,AInq.Optional.Try{`0})">
            <summary> Greater comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_LessThanOrEqual(`0,AInq.Optional.Try{`0})">
            <summary> Less or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
        <member name="M:AInq.Optional.Try`1.op_GreaterThanOrEqual(`0,AInq.Optional.Try{`0})">
            <summary> Greater or equal comparison </summary>
            <param name="a"> First element </param>
            <param name="b"> Second element </param>
        </member>
    </members>
</doc>
